{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Difficult Dialogs Tools to easily guide conversations towards a certain objective Install pip install difficult_dialogs Usage More examples here there are many ways one could create a conversation loop Ideally you would integrate this with intents and additional logic Sample output Here is an output where i always agree BOT: i was not sure if i existed i spent some time thinking about it and reached a conclusion i am a computer Do you agree with i am a computer ? USER: y BOT: computers process information Do you agree with computers process information ? USER: y BOT: i process information Do you agree with i process information ? USER: y BOT: thinking is a way of processing information Do you agree with thinking is a way of processing information ? USER: y BOT: i can think, at least in a limited fashion Do you agree with i can think, at least in a limited fashion ? USER: y BOT: this must mean that i exist you could argue thinking is not the right word for what i do but i process information there needs to be something doing the processing i process information, therefore i am Here is the same argument, but this time i always disagree BOT: i was not sure if i existed i spent some time thinking about it and reached a conclusion computers process information Do you agree with computers process information ? USER: n BOT: i am pretty sure that i receive input and perform calculations on it Do you agree with computers process information ? USER: n BOT: computers have central processing units for this purpose Do you agree with computers process information ? USER: n BOT: i am answering you, i must be reacting to information Do you agree with computers process information ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Information https://en.wikipedia.org/wiki/Artificial_intelligence Do you agree with computers process information ? USER: n BOT: We will have to agree to disagree for now i process information Do you agree with i process information ? USER: n BOT: We will have to agree to disagree for now i am a computer Do you agree with i am a computer ? USER: n BOT: i am pretty sure i have a CPU Do you agree with i am a computer ? USER: n BOT: you can kick my hardware, it's obvious i am a computer Do you agree with i am a computer ? USER: n BOT: i run on a operating system Do you agree with i am a computer ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Computer_hardware https://en.wikipedia.org/wiki/Computer https://en.wikipedia.org/wiki/Software Do you agree with i am a computer ? USER: n BOT: We will have to agree to disagree for now thinking is a way of processing information Do you agree with thinking is a way of processing information ? USER: n BOT: even if i just get answers from somewhere else that is similar to thinking, or remembering Do you agree with thinking is a way of processing information ? USER: n BOT: information comes in, opinion comes out, that's a bit like thinking Do you agree with thinking is a way of processing information ? USER: n BOT: you may not call it thinking, but it is a good analogy Do you agree with thinking is a way of processing information ? USER: n BOT: something is happening to make me answer you Do you agree with thinking is a way of processing information ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Information_processing_theory Do you agree with thinking is a way of processing information ? USER: n BOT: We will have to agree to disagree for now i can think, at least in a limited fashion Do you agree with i can think, at least in a limited fashion ? USER: n BOT: We will have to agree to disagree for now this must mean that i exist you could argue thinking is not the right word for what i do but i process information there needs to be something doing the processing i process information, therefore i am Policies A policy is a way to run an argument, it decides how the conversation will go You can make your own policies by overriding key methods, or you can use the default policies see example of DummyPolicy argument.intro is printed fully on start, it is meant to introduce the argument a .premise file will be picked randomly and read all statements inside a .premise file will be read, but in a random order no statements will be repeated when all statements inside a .premise file are read, another .premise file will be picked when all .premise files are read, argument.conclusion is printed fully, it is meant to deliver the conclusion we want to reach from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import KnowItAllPolicy, BasePolicy arg_folder = join(dirname(__file__), \"i_think_therefore_i_am\") arg = Argument(path=arg_folder) # ignore user input, just go trough all premises # dialog = BasePolicy(argument=arg) # defend when user disagrees dialog = KnowItAllPolicy(arg) # argument / user loop dialog.run_async() while True: try: if dialog.output: print(\"BOT: \" + dialog.output) if not dialog.finished: utterance = input(\"USER: \") dialog.submit_input(utterance) else: break except KeyboardInterrupt: dialog.finished = True break dialog.stop() You also have access to lower level details, policies can be used outside the run() loop from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import BasePolicy arg_folder = join(dirname(__file__), \"argument_template\") arg = Argument(path=arg_folder) dialog = BasePolicy(argument=arg) # argument manual control print(dialog.start()) while not dialog.finished: assertion = dialog.choose_premise() if assertion: print(assertion) for s in assertion.statements: print(s) print(assertion.sources) else: print(dialog.end()) Arguments An Argument is a set of premises, a argument is True if all it's premises are True Arguments can be loaded from file structuring a folder like this $ tree argument_template/ argument_template/ \u251c\u2500\u2500 argument.conclusion \u251c\u2500\u2500 argument.intro \u251c\u2500\u2500 X.premise \u251c\u2500\u2500 X.source \u251c\u2500\u2500 X.support \u2514\u2500\u2500 Y.premise folder name is the argument name X.premise is a premise the argument depends on X.support are \"comebacks\" for when user disagrees with premise X.source is information source for the premise X is the premise we are currently arguing for from difficult_dialogs.arguments import Argument from os.path import dirname, join arg = Argument() path = join(dirname(__file__), \"argument_template\") arg.load(path) assert arg.is_true assert arg.description == \"argument_template\" from pprint import pprint pprint(arg.as_json) \"\"\" {'conclusion': 'this concludes my argument that Z is indeed True\\n' ' i will use the next line to tell you something extra\\n' ' here is more info\\n' ' goodbye and thank you\\n' ' this file was a single message', 'intro': 'here i introduce the topic\\n' ' all lines in intro file are printed\\n' ' this is a single message about X\\n' ' topic introduced successfully', 'is_true': True, 'premises': [{'description': 'Y', 'is_true': True, 'sources': [], 'statements': [ 'when all statements are said i will tell you ' 'the conclusion\\n', 'statements are not dependent on each other'], 'support': []}, {'description': 'X', 'is_true': True, 'sources': ['http://SOURCE_CODE.com\\n', 'http://SCIENTIFIC_PAPER.net\\n', 'https://WIKIPEDIA.ORG'], 'statements': [ 'statements in .premise files are said in random ' 'order\\n', 'i will say this exactly once\\n', 'i will say all sentences in .premise files'], 'support': ['this works the same way as .premise\\n', 'i am spoken when you disagree with X\\n', 'X is True because i say so']}] } \"\"\" Premises A premise is a set of Statements, a premise is True if all it's statements are True A premise also has sources to back it up, and support dialog that can be interjected at will from difficult_dialogs.premises import Premise p = Premise(\"pizza tastes good\") p.add_statement(\"pizza is food\") p.add_statement(\"the taste of pizza is pleasant\") p.add_support_statement(\"i like pizza\") p.add_source(\"http://pizza_reviews.com\") for s in p.statements: assert s.is_true assert bool(p) == True p.statements[0].disagree() assert bool(p) == False assert p.as_json == {'is_true': False, 'sources': ['http://pizza_reviews.com'], 'statements': ['pizza is food', 'the taste of pizza is pleasant'], 'support': ['i like pizza'], 'description': 'pizza tastes good'} Statements A statement is the lowest level of a dialog, it is a text sentence that may be True or False from difficult_dialogs.statements import Statement s = Statement(\"i like pizza\") assert str(s) == \"i like pizza\" assert s.text == \"i like pizza\" assert bool(s) == True s.disagree() assert bool(s) == False s.agree() assert bool(s) == True","title":"Home"},{"location":"#difficult-dialogs","text":"Tools to easily guide conversations towards a certain objective","title":"Difficult Dialogs"},{"location":"#install","text":"pip install difficult_dialogs","title":"Install"},{"location":"#usage","text":"More examples here there are many ways one could create a conversation loop Ideally you would integrate this with intents and additional logic","title":"Usage"},{"location":"#sample-output","text":"Here is an output where i always agree BOT: i was not sure if i existed i spent some time thinking about it and reached a conclusion i am a computer Do you agree with i am a computer ? USER: y BOT: computers process information Do you agree with computers process information ? USER: y BOT: i process information Do you agree with i process information ? USER: y BOT: thinking is a way of processing information Do you agree with thinking is a way of processing information ? USER: y BOT: i can think, at least in a limited fashion Do you agree with i can think, at least in a limited fashion ? USER: y BOT: this must mean that i exist you could argue thinking is not the right word for what i do but i process information there needs to be something doing the processing i process information, therefore i am Here is the same argument, but this time i always disagree BOT: i was not sure if i existed i spent some time thinking about it and reached a conclusion computers process information Do you agree with computers process information ? USER: n BOT: i am pretty sure that i receive input and perform calculations on it Do you agree with computers process information ? USER: n BOT: computers have central processing units for this purpose Do you agree with computers process information ? USER: n BOT: i am answering you, i must be reacting to information Do you agree with computers process information ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Information https://en.wikipedia.org/wiki/Artificial_intelligence Do you agree with computers process information ? USER: n BOT: We will have to agree to disagree for now i process information Do you agree with i process information ? USER: n BOT: We will have to agree to disagree for now i am a computer Do you agree with i am a computer ? USER: n BOT: i am pretty sure i have a CPU Do you agree with i am a computer ? USER: n BOT: you can kick my hardware, it's obvious i am a computer Do you agree with i am a computer ? USER: n BOT: i run on a operating system Do you agree with i am a computer ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Computer_hardware https://en.wikipedia.org/wiki/Computer https://en.wikipedia.org/wiki/Software Do you agree with i am a computer ? USER: n BOT: We will have to agree to disagree for now thinking is a way of processing information Do you agree with thinking is a way of processing information ? USER: n BOT: even if i just get answers from somewhere else that is similar to thinking, or remembering Do you agree with thinking is a way of processing information ? USER: n BOT: information comes in, opinion comes out, that's a bit like thinking Do you agree with thinking is a way of processing information ? USER: n BOT: you may not call it thinking, but it is a good analogy Do you agree with thinking is a way of processing information ? USER: n BOT: something is happening to make me answer you Do you agree with thinking is a way of processing information ? USER: n BOT: here is the source of my information https://en.wikipedia.org/wiki/Information_processing_theory Do you agree with thinking is a way of processing information ? USER: n BOT: We will have to agree to disagree for now i can think, at least in a limited fashion Do you agree with i can think, at least in a limited fashion ? USER: n BOT: We will have to agree to disagree for now this must mean that i exist you could argue thinking is not the right word for what i do but i process information there needs to be something doing the processing i process information, therefore i am","title":"Sample output"},{"location":"#policies","text":"A policy is a way to run an argument, it decides how the conversation will go You can make your own policies by overriding key methods, or you can use the default policies see example of DummyPolicy argument.intro is printed fully on start, it is meant to introduce the argument a .premise file will be picked randomly and read all statements inside a .premise file will be read, but in a random order no statements will be repeated when all statements inside a .premise file are read, another .premise file will be picked when all .premise files are read, argument.conclusion is printed fully, it is meant to deliver the conclusion we want to reach from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import KnowItAllPolicy, BasePolicy arg_folder = join(dirname(__file__), \"i_think_therefore_i_am\") arg = Argument(path=arg_folder) # ignore user input, just go trough all premises # dialog = BasePolicy(argument=arg) # defend when user disagrees dialog = KnowItAllPolicy(arg) # argument / user loop dialog.run_async() while True: try: if dialog.output: print(\"BOT: \" + dialog.output) if not dialog.finished: utterance = input(\"USER: \") dialog.submit_input(utterance) else: break except KeyboardInterrupt: dialog.finished = True break dialog.stop() You also have access to lower level details, policies can be used outside the run() loop from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import BasePolicy arg_folder = join(dirname(__file__), \"argument_template\") arg = Argument(path=arg_folder) dialog = BasePolicy(argument=arg) # argument manual control print(dialog.start()) while not dialog.finished: assertion = dialog.choose_premise() if assertion: print(assertion) for s in assertion.statements: print(s) print(assertion.sources) else: print(dialog.end())","title":"Policies"},{"location":"#arguments","text":"An Argument is a set of premises, a argument is True if all it's premises are True Arguments can be loaded from file structuring a folder like this $ tree argument_template/ argument_template/ \u251c\u2500\u2500 argument.conclusion \u251c\u2500\u2500 argument.intro \u251c\u2500\u2500 X.premise \u251c\u2500\u2500 X.source \u251c\u2500\u2500 X.support \u2514\u2500\u2500 Y.premise folder name is the argument name X.premise is a premise the argument depends on X.support are \"comebacks\" for when user disagrees with premise X.source is information source for the premise X is the premise we are currently arguing for from difficult_dialogs.arguments import Argument from os.path import dirname, join arg = Argument() path = join(dirname(__file__), \"argument_template\") arg.load(path) assert arg.is_true assert arg.description == \"argument_template\" from pprint import pprint pprint(arg.as_json) \"\"\" {'conclusion': 'this concludes my argument that Z is indeed True\\n' ' i will use the next line to tell you something extra\\n' ' here is more info\\n' ' goodbye and thank you\\n' ' this file was a single message', 'intro': 'here i introduce the topic\\n' ' all lines in intro file are printed\\n' ' this is a single message about X\\n' ' topic introduced successfully', 'is_true': True, 'premises': [{'description': 'Y', 'is_true': True, 'sources': [], 'statements': [ 'when all statements are said i will tell you ' 'the conclusion\\n', 'statements are not dependent on each other'], 'support': []}, {'description': 'X', 'is_true': True, 'sources': ['http://SOURCE_CODE.com\\n', 'http://SCIENTIFIC_PAPER.net\\n', 'https://WIKIPEDIA.ORG'], 'statements': [ 'statements in .premise files are said in random ' 'order\\n', 'i will say this exactly once\\n', 'i will say all sentences in .premise files'], 'support': ['this works the same way as .premise\\n', 'i am spoken when you disagree with X\\n', 'X is True because i say so']}] } \"\"\"","title":"Arguments"},{"location":"#premises","text":"A premise is a set of Statements, a premise is True if all it's statements are True A premise also has sources to back it up, and support dialog that can be interjected at will from difficult_dialogs.premises import Premise p = Premise(\"pizza tastes good\") p.add_statement(\"pizza is food\") p.add_statement(\"the taste of pizza is pleasant\") p.add_support_statement(\"i like pizza\") p.add_source(\"http://pizza_reviews.com\") for s in p.statements: assert s.is_true assert bool(p) == True p.statements[0].disagree() assert bool(p) == False assert p.as_json == {'is_true': False, 'sources': ['http://pizza_reviews.com'], 'statements': ['pizza is food', 'the taste of pizza is pleasant'], 'support': ['i like pizza'], 'description': 'pizza tastes good'}","title":"Premises"},{"location":"#statements","text":"A statement is the lowest level of a dialog, it is a text sentence that may be True or False from difficult_dialogs.statements import Statement s = Statement(\"i like pizza\") assert str(s) == \"i like pizza\" assert s.text == \"i like pizza\" assert bool(s) == True s.disagree() assert bool(s) == False s.agree() assert bool(s) == True","title":"Statements"},{"location":"difficult_dialogs.arguments/","text":"Module difficult_dialogs.arguments Argument An Argument is a set of premises, a argument is True if all it's premises are True Arguments can be loaded from file structuring a folder like this $ tree argument_template/ argument_template/ \u251c\u2500\u2500 argument.conclusion \u251c\u2500\u2500 argument.intro \u251c\u2500\u2500 X.premise \u251c\u2500\u2500 X.source \u251c\u2500\u2500 X.support \u2514\u2500\u2500 Y.premise folder name is the argument name X.premise is a premise the argument depends on X.support are \"comebacks\" for when user disagrees with premise X.source is information source for the premise X is the premise we are currently arguing for from difficult_dialogs.arguments import Argument from os.path import dirname, join arg = Argument() path = join(dirname(__file__), \"argument_template\") arg.load(path) assert arg.is_true assert arg.description == \"argument_template\" from pprint import pprint pprint(arg.as_json) add_how def add_how(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings add_premise def add_premise(self, premise) add an premise to this argument premise should be an Premise object if premise is a string, an premise will be created from it if premise is a dictionary, an premise will be created from data if premise is a list, an premise will be created with list as statements add_source def add_source(self, source, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings add_statement def add_statement(self, statement, premise) adds a statement to an premise of this argument premise will be created or modified statement may be a string, Statement, list of strings or list of Statements add_support def add_support(self, support_statement, premise) adds a support statement to an premise of this argument premise will be created or modified support_statememt may be a string, Statement, list of strings or list of Statements add_what def add_what(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings add_when def add_when(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings add_where def add_where(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings add_why def add_why(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings agree def agree(self) flag all premises as True load def load(self, path=None) load argument from directory set_conclusion def set_conclusion(self, text) set argument conclusion from string or Statement set_description def set_description(self, text) set argument description from string set_intro def set_intro(self, text) set argument introduction from string or Statement update def update(self, argument) argument can be an Argument object or a dictionary with a \"premises\" field if argument is a list, each item will be added recursively premises will be updated or created","title":"arguments"},{"location":"difficult_dialogs.arguments/#module-difficult_dialogsarguments","text":"","title":"Module difficult_dialogs.arguments"},{"location":"difficult_dialogs.arguments/#argument","text":"An Argument is a set of premises, a argument is True if all it's premises are True Arguments can be loaded from file structuring a folder like this $ tree argument_template/ argument_template/ \u251c\u2500\u2500 argument.conclusion \u251c\u2500\u2500 argument.intro \u251c\u2500\u2500 X.premise \u251c\u2500\u2500 X.source \u251c\u2500\u2500 X.support \u2514\u2500\u2500 Y.premise folder name is the argument name X.premise is a premise the argument depends on X.support are \"comebacks\" for when user disagrees with premise X.source is information source for the premise X is the premise we are currently arguing for from difficult_dialogs.arguments import Argument from os.path import dirname, join arg = Argument() path = join(dirname(__file__), \"argument_template\") arg.load(path) assert arg.is_true assert arg.description == \"argument_template\" from pprint import pprint pprint(arg.as_json)","title":"Argument"},{"location":"difficult_dialogs.arguments/#add95how","text":"def add_how(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_how"},{"location":"difficult_dialogs.arguments/#add95premise","text":"def add_premise(self, premise) add an premise to this argument premise should be an Premise object if premise is a string, an premise will be created from it if premise is a dictionary, an premise will be created from data if premise is a list, an premise will be created with list as statements","title":"add_premise"},{"location":"difficult_dialogs.arguments/#add95source","text":"def add_source(self, source, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_source"},{"location":"difficult_dialogs.arguments/#add95statement","text":"def add_statement(self, statement, premise) adds a statement to an premise of this argument premise will be created or modified statement may be a string, Statement, list of strings or list of Statements","title":"add_statement"},{"location":"difficult_dialogs.arguments/#add95support","text":"def add_support(self, support_statement, premise) adds a support statement to an premise of this argument premise will be created or modified support_statememt may be a string, Statement, list of strings or list of Statements","title":"add_support"},{"location":"difficult_dialogs.arguments/#add95what","text":"def add_what(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_what"},{"location":"difficult_dialogs.arguments/#add95when","text":"def add_when(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_when"},{"location":"difficult_dialogs.arguments/#add95where","text":"def add_where(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_where"},{"location":"difficult_dialogs.arguments/#add95why","text":"def add_why(self, text, premise) adds a source to an premise of this argument premise will be created or modified source may be a string or list of strings","title":"add_why"},{"location":"difficult_dialogs.arguments/#agree","text":"def agree(self) flag all premises as True","title":"agree"},{"location":"difficult_dialogs.arguments/#load","text":"def load(self, path=None) load argument from directory","title":"load"},{"location":"difficult_dialogs.arguments/#set95conclusion","text":"def set_conclusion(self, text) set argument conclusion from string or Statement","title":"set_conclusion"},{"location":"difficult_dialogs.arguments/#set95description","text":"def set_description(self, text) set argument description from string","title":"set_description"},{"location":"difficult_dialogs.arguments/#set95intro","text":"def set_intro(self, text) set argument introduction from string or Statement","title":"set_intro"},{"location":"difficult_dialogs.arguments/#update","text":"def update(self, argument) argument can be an Argument object or a dictionary with a \"premises\" field if argument is a list, each item will be added recursively premises will be updated or created","title":"update"},{"location":"difficult_dialogs.exceptions/","text":"Module difficult_dialogs.exceptions BadArgumentJson tried to create an argument from bad json BadAssertionJson tried to create an assertion from bad json DifficultDialogsException something went wrong MissingAssertionException expecting at least 1 assertion object MissingStatementException expecting at least 1 statement object UnrecognizedArgumentFormat tried to create an argument from invalid input UnrecognizedConclusionFormat tried to create an argument conclusion from invalid input UnrecognizedDescriptionFormat tried to add a description from invalid input UnrecognizedIntroFormat tried to create an argument intro from invalid input UnrecognizedSourceFormat tried to create a source from invalid input UnrecognizedStatementFormat tried to create a statement from invalid input","title":"exceptions"},{"location":"difficult_dialogs.exceptions/#module-difficult_dialogsexceptions","text":"","title":"Module difficult_dialogs.exceptions"},{"location":"difficult_dialogs.exceptions/#badargumentjson","text":"tried to create an argument from bad json","title":"BadArgumentJson"},{"location":"difficult_dialogs.exceptions/#badassertionjson","text":"tried to create an assertion from bad json","title":"BadAssertionJson"},{"location":"difficult_dialogs.exceptions/#difficultdialogsexception","text":"something went wrong","title":"DifficultDialogsException"},{"location":"difficult_dialogs.exceptions/#missingassertionexception","text":"expecting at least 1 assertion object","title":"MissingAssertionException"},{"location":"difficult_dialogs.exceptions/#missingstatementexception","text":"expecting at least 1 statement object","title":"MissingStatementException"},{"location":"difficult_dialogs.exceptions/#unrecognizedargumentformat","text":"tried to create an argument from invalid input","title":"UnrecognizedArgumentFormat"},{"location":"difficult_dialogs.exceptions/#unrecognizedconclusionformat","text":"tried to create an argument conclusion from invalid input","title":"UnrecognizedConclusionFormat"},{"location":"difficult_dialogs.exceptions/#unrecognizeddescriptionformat","text":"tried to add a description from invalid input","title":"UnrecognizedDescriptionFormat"},{"location":"difficult_dialogs.exceptions/#unrecognizedintroformat","text":"tried to create an argument intro from invalid input","title":"UnrecognizedIntroFormat"},{"location":"difficult_dialogs.exceptions/#unrecognizedsourceformat","text":"tried to create a source from invalid input","title":"UnrecognizedSourceFormat"},{"location":"difficult_dialogs.exceptions/#unrecognizedstatementformat","text":"tried to create a statement from invalid input","title":"UnrecognizedStatementFormat"},{"location":"difficult_dialogs.policy/","text":"Module difficult_dialogs.policy BasePolicy A policy is a way to run an argument, it decides how the conversation will go You can make your own policies by overriding key methods, or you can use the default policies see example of DummyPolicy argument.intro is spoken on start, it is meant to introduce the argument a .premise file will be picked randomly and read all statements inside a .premise file will be read, but in a random order no statements will be repeated when all statements inside a .premise file are read, another .premise file will be picked when all .premise files are read, argument.conclusion is printed fully, it is meant to deliver the conclusion we want to reach from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import KnowItAllPolicy, BasePolicy arg_folder = join(dirname(__file__), \"i_think_therefore_i_am\") arg = Argument(path=arg_folder) # ignore user input, just go trough all premises # dialog = BasePolicy(argument=arg) # defend when user disagrees dialog = KnowItAllPolicy(arg) # argument / user loop dialog.run_async() while True: try: if dialog.output: print(\"BOT: \" + dialog.output) if not dialog.finished: utterance = input(\"USER: \") dialog.submit_input(utterance) else: break except KeyboardInterrupt: dialog.finished = True break dialog.stop() You also have access to lower level details, policies can be used without the run() loop from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import BasePolicy arg_folder = join(dirname(__file__), \"argument_template\") arg = Argument(path=arg_folder) dialog = BasePolicy(argument=arg) # argument manual control print(dialog.start()) while not dialog.finished: assertion = dialog.choose_premise() if assertion: print(assertion) for s in assertion.statements: print(s) print(assertion.sources) else: print(dialog.end()) agree def agree(self) Agree with current premise bind def bind(self, argument) NOTES: lib Args: argument: choose_next_statement def choose_next_statement(self, premise=None) select which Statement to tackle next Returns: next statement (Statement) choose_premise def choose_premise(self, argument=None) select which Premise to tackle next Returns: next premise (Premise) disagree def disagree(self) Disagree with current premise end def end(self) handle outcome of dialog unset running flag, self.finished = True return speak conclusion statement Returns: conclusion statement (str) get_feedback def get_feedback(self, prompt=None) used in run(), if running async wait_for_feedback is used instead ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False how def how(self, default_answer=\"i don't know how\") explain how current statement is_cached def is_cached(self, entry) check if entry was used already Args: entry: text or Statement Returns: is_cached (bool) on_negative_feedback def on_negative_feedback(self) react to negative feedback by default goes to next statement on_positive_feedback def on_positive_feedback(self) react to positive feedback by default goes to next statement on_user_input def on_user_input(self, text) NOTES: events handle user input intent parsing should be done here typical actions are calling self.agree() or self.disagree() to direct the policy (return True) calling self.what(), self.why(), self.how(), self.when(), self.where() and setting the output (return False) NOTE: only when running async return True or False, this determines if dialog should proceed or wait for different user input reprompt def reprompt(self) Speak last used prompt Returns: last prompt (str) reset def reset(self) run def run(self) run the interaction, ask if user agrees or not after every statement NOTE: ignores on user input callback, mostly meant for quick testing run_async def run_async(self) Start listening for user input skip_feedback def skip_feedback(self) Do not ask for user feedback sources def sources(self, default_answer=\"i don't remember where i learned this\") sources of current statement speak def speak(self, text) normalize text cache response, self._cache_this(text) manage output, self._output += text return normalized text start def start(self) NOTES: dialog actions prepare context of dialog reset policy, self.reset() set running flag, self.finished = False speak intro statement Returns: intro statement (str) stop def stop(self) Stop listening for user input submit_input def submit_input(self, text) Args: text: utterance (str) wait_for_feedback def wait_for_feedback(self, prompt=None) ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False wait_for_input def wait_for_input(self) NOTES: async wait until self.submit_input is called what def what(self, default_answer=\"i don't know how to explain\") explain current statement when def when(self, default_answer=\"i don't know when\") explain when current statement happened where def where(self, default_answer=\"i don't know where\") explain where current statement happened why def why(self, default_answer=\"i don't know why\") explain cause of current statement KnowItAllPolicy agree def agree(self) Agree with current premise bind def bind(self, argument) NOTES: lib Args: argument: choose_next_statement def choose_next_statement(self, premise=None) select which Statement to tackle next Returns: next statement (Statement) choose_premise def choose_premise(self, argument=None) select which Premise to tackle next Returns: next premise (Premise) disagree def disagree(self) Disagree with current premise end def end(self) handle outcome of dialog unset running flag, self.finished = True return speak conclusion statement Returns: conclusion statement (str) get_feedback def get_feedback(self, prompt=None) used in run(), if running async wait_for_feedback is used instead ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False how def how(self, default_answer=\"i don't know how\") explain how current statement is_cached def is_cached(self, entry) check if entry was used already Args: entry: text or Statement Returns: is_cached (bool) on_complete_failure def on_complete_failure(self) handle failure to get a response, called by on_negative_feedback if no support statements available typically you will return a failure message and manage the dialog state to control the dialog loop you will typically use: self.agree() / self.disagree() - decide if on_negative_feedback or on_positive_feedback should be called self.skip_feedback() - do not get user input Returns: sentence to speak (str) on_negative_feedback def on_negative_feedback(self) react to negative feedback usually you will take corrective action here and manage the dialog state to control the dialog loop you will typically use: self.agree() / self.disagree() - decide if on_negative_feedback or on_positive_feedback should be called self.skip_feedback() - do not get user input by default speak a support statement if no more support statements call on_complete_failure on_positive_feedback def on_positive_feedback(self) react to positive feedback by default goes to next statement on_user_input def on_user_input(self, text) handle user input answers what, why, how, where, when questions or proceeds with dialog reprompt def reprompt(self) Speak last used prompt Returns: last prompt (str) reset def reset(self) run def run(self) run the interaction, ask if user agrees or not after every statement NOTE: ignores on user input callback, mostly meant for quick testing run_async def run_async(self) Start listening for user input skip_feedback def skip_feedback(self) Do not ask for user feedback sources def sources(self, default_answer=\"i don't remember where i learned this\") sources of current statement speak def speak(self, text) normalize text cache response, self._cache_this(text) manage output, self._output += text return normalized text start def start(self) NOTES: dialog actions prepare context of dialog reset policy, self.reset() set running flag, self.finished = False speak intro statement Returns: intro statement (str) stop def stop(self) Stop listening for user input submit_input def submit_input(self, text) Args: text: utterance (str) wait_for_feedback def wait_for_feedback(self, prompt=None) ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False wait_for_input def wait_for_input(self) NOTES: async wait until self.submit_input is called what def what(self, default_answer=\"i don't know how to explain\") explain current statement when def when(self, default_answer=\"i don't know when\") explain when current statement happened where def where(self, default_answer=\"i don't know where\") explain where current statement happened why def why(self, default_answer=\"i don't know why\") explain cause of current statement","title":"policy"},{"location":"difficult_dialogs.policy/#module-difficult_dialogspolicy","text":"","title":"Module difficult_dialogs.policy"},{"location":"difficult_dialogs.policy/#basepolicy","text":"A policy is a way to run an argument, it decides how the conversation will go You can make your own policies by overriding key methods, or you can use the default policies see example of DummyPolicy argument.intro is spoken on start, it is meant to introduce the argument a .premise file will be picked randomly and read all statements inside a .premise file will be read, but in a random order no statements will be repeated when all statements inside a .premise file are read, another .premise file will be picked when all .premise files are read, argument.conclusion is printed fully, it is meant to deliver the conclusion we want to reach from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import KnowItAllPolicy, BasePolicy arg_folder = join(dirname(__file__), \"i_think_therefore_i_am\") arg = Argument(path=arg_folder) # ignore user input, just go trough all premises # dialog = BasePolicy(argument=arg) # defend when user disagrees dialog = KnowItAllPolicy(arg) # argument / user loop dialog.run_async() while True: try: if dialog.output: print(\"BOT: \" + dialog.output) if not dialog.finished: utterance = input(\"USER: \") dialog.submit_input(utterance) else: break except KeyboardInterrupt: dialog.finished = True break dialog.stop() You also have access to lower level details, policies can be used without the run() loop from os.path import join, dirname from difficult_dialogs.arguments import Argument from difficult_dialogs.policy import BasePolicy arg_folder = join(dirname(__file__), \"argument_template\") arg = Argument(path=arg_folder) dialog = BasePolicy(argument=arg) # argument manual control print(dialog.start()) while not dialog.finished: assertion = dialog.choose_premise() if assertion: print(assertion) for s in assertion.statements: print(s) print(assertion.sources) else: print(dialog.end())","title":"BasePolicy"},{"location":"difficult_dialogs.policy/#agree","text":"def agree(self) Agree with current premise","title":"agree"},{"location":"difficult_dialogs.policy/#bind","text":"def bind(self, argument) NOTES: lib Args: argument:","title":"bind"},{"location":"difficult_dialogs.policy/#choose95next95statement","text":"def choose_next_statement(self, premise=None) select which Statement to tackle next Returns: next statement (Statement)","title":"choose_next_statement"},{"location":"difficult_dialogs.policy/#choose95premise","text":"def choose_premise(self, argument=None) select which Premise to tackle next Returns: next premise (Premise)","title":"choose_premise"},{"location":"difficult_dialogs.policy/#disagree","text":"def disagree(self) Disagree with current premise","title":"disagree"},{"location":"difficult_dialogs.policy/#end","text":"def end(self) handle outcome of dialog unset running flag, self.finished = True return speak conclusion statement Returns: conclusion statement (str)","title":"end"},{"location":"difficult_dialogs.policy/#get95feedback","text":"def get_feedback(self, prompt=None) used in run(), if running async wait_for_feedback is used instead ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False","title":"get_feedback"},{"location":"difficult_dialogs.policy/#how","text":"def how(self, default_answer=\"i don't know how\") explain how current statement","title":"how"},{"location":"difficult_dialogs.policy/#is95cached","text":"def is_cached(self, entry) check if entry was used already Args: entry: text or Statement Returns: is_cached (bool)","title":"is_cached"},{"location":"difficult_dialogs.policy/#on95negative95feedback","text":"def on_negative_feedback(self) react to negative feedback by default goes to next statement","title":"on_negative_feedback"},{"location":"difficult_dialogs.policy/#on95positive95feedback","text":"def on_positive_feedback(self) react to positive feedback by default goes to next statement","title":"on_positive_feedback"},{"location":"difficult_dialogs.policy/#on95user95input","text":"def on_user_input(self, text) NOTES: events handle user input intent parsing should be done here typical actions are calling self.agree() or self.disagree() to direct the policy (return True) calling self.what(), self.why(), self.how(), self.when(), self.where() and setting the output (return False) NOTE: only when running async return True or False, this determines if dialog should proceed or wait for different user input","title":"on_user_input"},{"location":"difficult_dialogs.policy/#reprompt","text":"def reprompt(self) Speak last used prompt Returns: last prompt (str)","title":"reprompt"},{"location":"difficult_dialogs.policy/#reset","text":"def reset(self)","title":"reset"},{"location":"difficult_dialogs.policy/#run","text":"def run(self) run the interaction, ask if user agrees or not after every statement NOTE: ignores on user input callback, mostly meant for quick testing","title":"run"},{"location":"difficult_dialogs.policy/#run95async","text":"def run_async(self) Start listening for user input","title":"run_async"},{"location":"difficult_dialogs.policy/#skip95feedback","text":"def skip_feedback(self) Do not ask for user feedback","title":"skip_feedback"},{"location":"difficult_dialogs.policy/#sources","text":"def sources(self, default_answer=\"i don't remember where i learned this\") sources of current statement","title":"sources"},{"location":"difficult_dialogs.policy/#speak","text":"def speak(self, text) normalize text cache response, self._cache_this(text) manage output, self._output += text return normalized text","title":"speak"},{"location":"difficult_dialogs.policy/#start","text":"def start(self) NOTES: dialog actions prepare context of dialog reset policy, self.reset() set running flag, self.finished = False speak intro statement Returns: intro statement (str)","title":"start"},{"location":"difficult_dialogs.policy/#stop","text":"def stop(self) Stop listening for user input","title":"stop"},{"location":"difficult_dialogs.policy/#submit95input","text":"def submit_input(self, text) Args: text: utterance (str)","title":"submit_input"},{"location":"difficult_dialogs.policy/#wait95for95feedback","text":"def wait_for_feedback(self, prompt=None) ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False","title":"wait_for_feedback"},{"location":"difficult_dialogs.policy/#wait95for95input","text":"def wait_for_input(self) NOTES: async wait until self.submit_input is called","title":"wait_for_input"},{"location":"difficult_dialogs.policy/#what","text":"def what(self, default_answer=\"i don't know how to explain\") explain current statement","title":"what"},{"location":"difficult_dialogs.policy/#when","text":"def when(self, default_answer=\"i don't know when\") explain when current statement happened","title":"when"},{"location":"difficult_dialogs.policy/#where","text":"def where(self, default_answer=\"i don't know where\") explain where current statement happened","title":"where"},{"location":"difficult_dialogs.policy/#why","text":"def why(self, default_answer=\"i don't know why\") explain cause of current statement","title":"why"},{"location":"difficult_dialogs.policy/#knowitallpolicy","text":"","title":"KnowItAllPolicy"},{"location":"difficult_dialogs.policy/#agree_1","text":"def agree(self) Agree with current premise","title":"agree"},{"location":"difficult_dialogs.policy/#bind_1","text":"def bind(self, argument) NOTES: lib Args: argument:","title":"bind"},{"location":"difficult_dialogs.policy/#choose95next95statement_1","text":"def choose_next_statement(self, premise=None) select which Statement to tackle next Returns: next statement (Statement)","title":"choose_next_statement"},{"location":"difficult_dialogs.policy/#choose95premise_1","text":"def choose_premise(self, argument=None) select which Premise to tackle next Returns: next premise (Premise)","title":"choose_premise"},{"location":"difficult_dialogs.policy/#disagree_1","text":"def disagree(self) Disagree with current premise","title":"disagree"},{"location":"difficult_dialogs.policy/#end_1","text":"def end(self) handle outcome of dialog unset running flag, self.finished = True return speak conclusion statement Returns: conclusion statement (str)","title":"end"},{"location":"difficult_dialogs.policy/#get95feedback_1","text":"def get_feedback(self, prompt=None) used in run(), if running async wait_for_feedback is used instead ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False","title":"get_feedback"},{"location":"difficult_dialogs.policy/#how_1","text":"def how(self, default_answer=\"i don't know how\") explain how current statement","title":"how"},{"location":"difficult_dialogs.policy/#is95cached_1","text":"def is_cached(self, entry) check if entry was used already Args: entry: text or Statement Returns: is_cached (bool)","title":"is_cached"},{"location":"difficult_dialogs.policy/#on95complete95failure","text":"def on_complete_failure(self) handle failure to get a response, called by on_negative_feedback if no support statements available typically you will return a failure message and manage the dialog state to control the dialog loop you will typically use: self.agree() / self.disagree() - decide if on_negative_feedback or on_positive_feedback should be called self.skip_feedback() - do not get user input Returns: sentence to speak (str)","title":"on_complete_failure"},{"location":"difficult_dialogs.policy/#on95negative95feedback_1","text":"def on_negative_feedback(self) react to negative feedback usually you will take corrective action here and manage the dialog state to control the dialog loop you will typically use: self.agree() / self.disagree() - decide if on_negative_feedback or on_positive_feedback should be called self.skip_feedback() - do not get user input by default speak a support statement if no more support statements call on_complete_failure","title":"on_negative_feedback"},{"location":"difficult_dialogs.policy/#on95positive95feedback_1","text":"def on_positive_feedback(self) react to positive feedback by default goes to next statement","title":"on_positive_feedback"},{"location":"difficult_dialogs.policy/#on95user95input_1","text":"def on_user_input(self, text) handle user input answers what, why, how, where, when questions or proceeds with dialog","title":"on_user_input"},{"location":"difficult_dialogs.policy/#reprompt_1","text":"def reprompt(self) Speak last used prompt Returns: last prompt (str)","title":"reprompt"},{"location":"difficult_dialogs.policy/#reset_1","text":"def reset(self)","title":"reset"},{"location":"difficult_dialogs.policy/#run_1","text":"def run(self) run the interaction, ask if user agrees or not after every statement NOTE: ignores on user input callback, mostly meant for quick testing","title":"run"},{"location":"difficult_dialogs.policy/#run95async_1","text":"def run_async(self) Start listening for user input","title":"run_async"},{"location":"difficult_dialogs.policy/#skip95feedback_1","text":"def skip_feedback(self) Do not ask for user feedback","title":"skip_feedback"},{"location":"difficult_dialogs.policy/#sources_1","text":"def sources(self, default_answer=\"i don't remember where i learned this\") sources of current statement","title":"sources"},{"location":"difficult_dialogs.policy/#speak_1","text":"def speak(self, text) normalize text cache response, self._cache_this(text) manage output, self._output += text return normalized text","title":"speak"},{"location":"difficult_dialogs.policy/#start_1","text":"def start(self) NOTES: dialog actions prepare context of dialog reset policy, self.reset() set running flag, self.finished = False speak intro statement Returns: intro statement (str)","title":"start"},{"location":"difficult_dialogs.policy/#stop_1","text":"def stop(self) Stop listening for user input","title":"stop"},{"location":"difficult_dialogs.policy/#submit95input_1","text":"def submit_input(self, text) Args: text: utterance (str)","title":"submit_input"},{"location":"difficult_dialogs.policy/#wait95for95feedback_1","text":"def wait_for_feedback(self, prompt=None) ask user if he agrees with current statement or not prompt is a string or list of strings, if it's a list a random entry will be picked return True or False","title":"wait_for_feedback"},{"location":"difficult_dialogs.policy/#wait95for95input_1","text":"def wait_for_input(self) NOTES: async wait until self.submit_input is called","title":"wait_for_input"},{"location":"difficult_dialogs.policy/#what_1","text":"def what(self, default_answer=\"i don't know how to explain\") explain current statement","title":"what"},{"location":"difficult_dialogs.policy/#when_1","text":"def when(self, default_answer=\"i don't know when\") explain when current statement happened","title":"when"},{"location":"difficult_dialogs.policy/#where_1","text":"def where(self, default_answer=\"i don't know where\") explain where current statement happened","title":"where"},{"location":"difficult_dialogs.policy/#why_1","text":"def why(self, default_answer=\"i don't know why\") explain cause of current statement","title":"why"},{"location":"difficult_dialogs.premises/","text":"Module difficult_dialogs.premises Premise A premise is a set of Statements, a premise is True if all it's statements are True A premise also has sources to back it up, and support dialog that can be interjected at will from difficult_dialogs.premises import Premise p = Premise(\"pizza tastes good\") p.add_statement(\"pizza is food\") p.add_statement(\"the taste of pizza is pleasant\") p.add_support_statement(\"i like pizza\") p.add_source(\"http://pizza_reviews.com\") for s in p.statements: assert s.is_true assert bool(p) == True p.statements[0].disagree() assert bool(p) == False assert p.as_json == {'is_true': False, 'sources': ['http://pizza_reviews.com'], 'statements': ['pizza is food', 'the taste of pizza is pleasant'], 'support': ['i like pizza'], 'description': 'pizza tastes good'} add_how_statement def add_how_statement(self, text) Args: text: add_source def add_source(self, text) Args: text: add_statement def add_statement(self, text) Args: text: add_support_statement def add_support_statement(self, text) Args: text: add_what_statement def add_what_statement(self, text) Args: text: add_when_statement def add_when_statement(self, text) Args: text: add_where_statement def add_where_statement(self, text) Args: text: add_why_statement def add_why_statement(self, text) Args: text: agree def agree(self) flag all statements as True from_json def from_json(self, json_dict) Args: json_dict: set_description def set_description(self, text) set premise description from string update def update(self, premise) if premise is an Premise object or dictionary, statements, support and sources will be merged if premise is a string, a support statement will be merged if premise is a list, each item will be added recursively validate_statement def validate_statement(statement) Args: statement: Returns:","title":"premises"},{"location":"difficult_dialogs.premises/#module-difficult_dialogspremises","text":"","title":"Module difficult_dialogs.premises"},{"location":"difficult_dialogs.premises/#premise","text":"A premise is a set of Statements, a premise is True if all it's statements are True A premise also has sources to back it up, and support dialog that can be interjected at will from difficult_dialogs.premises import Premise p = Premise(\"pizza tastes good\") p.add_statement(\"pizza is food\") p.add_statement(\"the taste of pizza is pleasant\") p.add_support_statement(\"i like pizza\") p.add_source(\"http://pizza_reviews.com\") for s in p.statements: assert s.is_true assert bool(p) == True p.statements[0].disagree() assert bool(p) == False assert p.as_json == {'is_true': False, 'sources': ['http://pizza_reviews.com'], 'statements': ['pizza is food', 'the taste of pizza is pleasant'], 'support': ['i like pizza'], 'description': 'pizza tastes good'}","title":"Premise"},{"location":"difficult_dialogs.premises/#add95how95statement","text":"def add_how_statement(self, text) Args: text:","title":"add_how_statement"},{"location":"difficult_dialogs.premises/#add95source","text":"def add_source(self, text) Args: text:","title":"add_source"},{"location":"difficult_dialogs.premises/#add95statement","text":"def add_statement(self, text) Args: text:","title":"add_statement"},{"location":"difficult_dialogs.premises/#add95support95statement","text":"def add_support_statement(self, text) Args: text:","title":"add_support_statement"},{"location":"difficult_dialogs.premises/#add95what95statement","text":"def add_what_statement(self, text) Args: text:","title":"add_what_statement"},{"location":"difficult_dialogs.premises/#add95when95statement","text":"def add_when_statement(self, text) Args: text:","title":"add_when_statement"},{"location":"difficult_dialogs.premises/#add95where95statement","text":"def add_where_statement(self, text) Args: text:","title":"add_where_statement"},{"location":"difficult_dialogs.premises/#add95why95statement","text":"def add_why_statement(self, text) Args: text:","title":"add_why_statement"},{"location":"difficult_dialogs.premises/#agree","text":"def agree(self) flag all statements as True","title":"agree"},{"location":"difficult_dialogs.premises/#from95json","text":"def from_json(self, json_dict) Args: json_dict:","title":"from_json"},{"location":"difficult_dialogs.premises/#set95description","text":"def set_description(self, text) set premise description from string","title":"set_description"},{"location":"difficult_dialogs.premises/#update","text":"def update(self, premise) if premise is an Premise object or dictionary, statements, support and sources will be merged if premise is a string, a support statement will be merged if premise is a list, each item will be added recursively","title":"update"},{"location":"difficult_dialogs.premises/#validate95statement","text":"def validate_statement(statement) Args: statement: Returns:","title":"validate_statement"},{"location":"difficult_dialogs.statements/","text":"Module difficult_dialogs.statements Statement A statement is the lowest level of a dialog, it is a text sentence that may be True or False from difficult_dialogs.statements import Statement s = Statement(\"i like pizza\") assert str(s) == \"i like pizza\" assert s.text == \"i like pizza\" assert bool(s) == True s.disagree() assert bool(s) == False s.agree() assert bool(s) == True agree def agree(self) set statement to True disagree def disagree(self) set statement to False from_json def from_json(self, json_dict) set properties from json Args: json_dict: json representation (dict) :return:","title":"statements"},{"location":"difficult_dialogs.statements/#module-difficult_dialogsstatements","text":"","title":"Module difficult_dialogs.statements"},{"location":"difficult_dialogs.statements/#statement","text":"A statement is the lowest level of a dialog, it is a text sentence that may be True or False from difficult_dialogs.statements import Statement s = Statement(\"i like pizza\") assert str(s) == \"i like pizza\" assert s.text == \"i like pizza\" assert bool(s) == True s.disagree() assert bool(s) == False s.agree() assert bool(s) == True","title":"Statement"},{"location":"difficult_dialogs.statements/#agree","text":"def agree(self) set statement to True","title":"agree"},{"location":"difficult_dialogs.statements/#disagree","text":"def disagree(self) set statement to False","title":"disagree"},{"location":"difficult_dialogs.statements/#from95json","text":"def from_json(self, json_dict) set properties from json Args: json_dict: json representation (dict) :return:","title":"from_json"}]}